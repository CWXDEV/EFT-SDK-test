using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace EFT.Interactive
{
	// Token: 0x020027F7 RID: 10231
	public class WindowBreakingConfig : ScriptableObject
	{
		// Token: 0x0600CCD0 RID: 52432 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void OnValidate()
		{
			throw null;
		}

		// Token: 0x0600CCD1 RID: 52433 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static Mesh GenerateMesh(Vector2[] points, Vector2 center, float halfWith)
		{
			throw null;
		}

		// Token: 0x0600CCD2 RID: 52434 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static Mesh GenerateMesh(Vector2[] points, Vector2 center, bool swap, Vector2 uvMult, Vector2 uvAdd, Vector2 zSurfs)
		{
			throw null;
		}

		// Token: 0x0600CCD3 RID: 52435 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static WindowBreakingConfig.GClass2976 GenerateMeshPice(Vector2[] points, bool swap, Vector2 uvMult, Vector2 uvAdd, Vector2 zSurfs, float edgesWidth)
		{
			throw null;
		}

		// Token: 0x0600CCD4 RID: 52436 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static Mesh CombineMeshPieces(WindowBreakingConfig.GClass2976[] pieces)
		{
			throw null;
		}

		// Token: 0x0600CCD5 RID: 52437 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static WindowBreakingConfig.Polygon GetPolygonFormMesh(Mesh mesh, float scale)
		{
			throw null;
		}

		// Token: 0x0600CCD6 RID: 52438 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static int smethod_0(ref Vector2 p0, ref Vector2 p1, Vector4 box)
		{
			throw null;
		}

		// Token: 0x0600CCD7 RID: 52439 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static int smethod_1(ref Vector2 p0, ref Vector2 p1, bool xAxis, bool positive, float value)
		{
			throw null;
		}

		// Token: 0x0600CCD8 RID: 52440 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static Vector2 smethod_2(Vector2 pIn, Vector2 pOut, bool xAxis, float value)
		{
			throw null;
		}

		// Token: 0x0600CCD9 RID: 52441 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static void smethod_3(List<Vector2> newList, List<Vector2> points, bool xAxis, bool positive, float value)
		{
			throw null;
		}

		// Token: 0x0600CCDA RID: 52442 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static Vector2 GetXAxis(float angle)
		{
			throw null;
		}

		// Token: 0x0600CCDB RID: 52443 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static Vector2[] smethod_4(Vector2[] points, Vector2 xAxis)
		{
			throw null;
		}

		// Token: 0x0600CCDC RID: 52444 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static Vector2[] smethod_5(Vector2[] points, Vector4 box, out bool noIntersects)
		{
			throw null;
		}

		// Token: 0x0600CCDD RID: 52445 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static int smethod_6(Vector2[] points, Vector4 box)
		{
			throw null;
		}

		// Token: 0x0600CCDE RID: 52446 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static int smethod_7(List<Vector2> points, bool xAxis, bool positive, float value)
		{
			throw null;
		}

		// Token: 0x0600CCDF RID: 52447 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static int[] smethod_8(Vector2[] points)
		{
			throw null;
		}

		// Token: 0x0600CCE0 RID: 52448 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static float smethod_9(Vector2[] points)
		{
			throw null;
		}

		// Token: 0x0600CCE1 RID: 52449 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static void smethod_10(Vector3[] points, out int axisX, out int axisY)
		{
			throw null;
		}

		// Token: 0x0600CCE2 RID: 52450 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static void DetectPlane(Vector3 size, out int axisX, out int axisY)
		{
			throw null;
		}

		// Token: 0x0600CCE3 RID: 52451 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static void DetectPlane(Vector3 size, out int axisX, out int axisY, out int axisZ)
		{
			throw null;
		}

		// Token: 0x0600CCE4 RID: 52452 RVA: 0x00002050 File Offset: 0x00000250
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static Vector2[] smethod_11(int count)
		{
			throw null;
		}

		// Token: 0x0400CD1B RID: 52507
		private static readonly List<Vector2> list_0;

		// Token: 0x0400CD1C RID: 52508
		private static readonly List<Vector2> list_1;

		// Token: 0x0400CD1D RID: 52509
		public WindowBreakingConfig.Crack[] Cracks;

		// Token: 0x0400CD1E RID: 52510
		private const int int_0 = 128;

		// Token: 0x0400CD1F RID: 52511
		private static Vector2[] vector2_0;

		// Token: 0x0400CD20 RID: 52512
		private static int int_1;

		// Token: 0x020027F8 RID: 10232
		[Serializable]
		public class Polygon
		{
			// Token: 0x0600CCE5 RID: 52453 RVA: 0x00002050 File Offset: 0x00000250
			[MethodImpl(MethodImplOptions.NoInlining)]
			public WindowBreakingConfig.Polygon CutPolygon(Vector4 box)
			{
				throw null;
			}

			// Token: 0x0600CCE6 RID: 52454 RVA: 0x00002050 File Offset: 0x00000250
			[MethodImpl(MethodImplOptions.NoInlining)]
			public WindowBreakingConfig.Polygon CutPolygon(Vector4 box, Vector2 xAxis)
			{
				throw null;
			}

			// Token: 0x0600CCE7 RID: 52455 RVA: 0x00002050 File Offset: 0x00000250
			[MethodImpl(MethodImplOptions.NoInlining)]
			public void DebugDraw(Color color)
			{
				throw null;
			}

			// Token: 0x0400CD21 RID: 52513
			public Vector2[] Points;

			// Token: 0x0400CD22 RID: 52514
			public float[] Distances;

			// Token: 0x0400CD23 RID: 52515
			public float[] RandomRanges;

			// Token: 0x0400CD24 RID: 52516
			public float Mass;

			// Token: 0x0400CD25 RID: 52517
			public bool Intersects;
		}

		// Token: 0x020027F9 RID: 10233
		[Serializable]
		public class Crack
		{
			// Token: 0x0400CD26 RID: 52518
			public WindowBreakingConfig.Polygon[] Polygons;

			// Token: 0x0400CD27 RID: 52519
			public bool GetFromSelectedMeshes;

			// Token: 0x0400CD28 RID: 52520
			public float Scale;

			// Token: 0x0400CD29 RID: 52521
			public GameObject Glass;
		}

		// Token: 0x020027FA RID: 10234
		public class GClass2976
		{
			// Token: 0x0600CCE8 RID: 52456 RVA: 0x00002050 File Offset: 0x00000250
			[MethodImpl(MethodImplOptions.NoInlining)]
			public Mesh GetMesh(Vector2 center)
			{
				throw null;
			}

			// Token: 0x0400CD2A RID: 52522
			public int[] Triangles;

			// Token: 0x0400CD2B RID: 52523
			public Vector3[] Vertices;

			// Token: 0x0400CD2C RID: 52524
			public Vector3[] Normals;

			// Token: 0x0400CD2D RID: 52525
			public Vector2[] Uv;
		}
	}
}
